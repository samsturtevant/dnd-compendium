# This file is an example of processing you might want to do to
# your vault to make it a bit more presentable / user friendly
# This one in particular cleans up dataviews to look better

import re
import glob


def format_info_box_line(line):
    """
    Helper function to format a single line of an info box.
    Returns the formatted HTML string for the line.
    """
    line = line.strip()
    if not line:
        return None
    
    # Handle image references - keep as markdown
    if line.startswith('![[') and line.endswith(']]'):
        return f'<div class="info-box-image" markdown="1">\n\n{line}\n\n</div>\n\n'
    
    # Handle key-value pairs - keep markdown links intact
    elif ':' in line:
        key, value = line.split(':', 1)
        key = key.strip()
        value = value.strip()
        # Only process if we have both key and value
        if key and value:
            # Use div with markdown block to allow proper processing
            # Structure: outer div -> paragraph (auto-generated by markdown processor) -> strong and span (for value)
            # The span wrapper ensures proper flexbox behavior for multi-line content
            return f'<div class="info-box-row" markdown="block"><strong>{key}:</strong><span class="info-box-value" markdown="span">{value}</span></div>\n\n'
    
    return None


def process_block_tags(content):
    """
    Process <block> tags into info boxes.
    
    Converts:
    <block>
    ![[image.png]]
    Key: Value
    Another: [[Link]]
    </block>
    
    Into an HTML info box that floats to the right like Wikipedia.
    The content is left as markdown (with wikilinks) to be processed later.
    """
    pattern = r'<block>\s*([\s\S]*?)\s*</block>'
    
    def replace_block(match):
        block_content = match.group(1)
        
        lines = block_content.strip().split('\n')
        html_parts = ['<div class="info-box" markdown="1">\n\n']
        
        for line in lines:
            formatted_line = format_info_box_line(line)
            if formatted_line:
                html_parts.append(formatted_line)
        
        html_parts.append('</div>\n\n')
        
        return ''.join(html_parts)
    
    return re.sub(pattern, replace_block, content)


def process_info_box(content):
    """
    Process info box blocks at the start of files.
    
    Converts:
    ```
    ![[image.png]]
    Key: Value
    Another: [[Link]]
    ```
    
    Into an HTML info box that floats to the right like Wikipedia.
    The content is left as markdown (with wikilinks) to be processed later.
    """
    # Match code blocks at the very start of the file (after optional whitespace)
    # that contain image references and key-value pairs
    pattern = r'^(\s*)```\s*\n([\s\S]*?)\n```'
    
    def replace_info_box(match):
        leading_space = match.group(1)
        block_content = match.group(2)
        
        # Check if this looks like an info box (has image or key-value pairs)
        has_image = re.search(r'!\[\[.*?\]\]', block_content)
        has_key_value = re.search(r'^[^:\n]+:.+$', block_content, re.MULTILINE)
        
        if not (has_image or has_key_value):
            # Not an info box, leave it as-is
            return match.group(0)
        
        lines = block_content.strip().split('\n')
        html_parts = ['<div class="info-box" markdown="1">\n\n']
        
        for line in lines:
            formatted_line = format_info_box_line(line)
            if formatted_line:
                html_parts.append(formatted_line)
        
        html_parts.append('</div>\n\n')
        
        return leading_space + ''.join(html_parts)
    
    # Only match at the start of the content
    return re.sub(pattern, replace_info_box, content, count=1)


# Process Dataview queries into Markdown tables
def process_dataview(file_path):
    with open(file_path, "r", encoding="utf-8") as file:
        content = file.read()

    # Process <block> tags first (Obsidian-friendly info boxes)
    content = process_block_tags(content)
    
    # Process info boxes (triple-backtick format)
    content = process_info_box(content)

    # Replace `dataview` blocks with a placeholder (customize as needed)
    content = re.sub(r"```dataview([\s\S]*?)```", "Dataview Query: \\1", content)
    
    # Remove #wiki tags (they're used for filtering but shouldn't be displayed)
    # Match #wiki on its own line or at the end of a line
    content = re.sub(r"^\s*#wiki\s*$|\s+#wiki\s*$", "", content, flags=re.MULTILINE)

    with open(file_path, "w", encoding="utf-8") as file:
        file.write(content)


# Find and process all Markdown files
for md_file in glob.glob(".site_content/**/*.md", recursive=True):
    process_dataview(md_file)
